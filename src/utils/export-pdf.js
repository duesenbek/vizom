/**
 * Export chart/container to PDF
 * - Supports Canvas/HTML via html2canvas
 * - Attempts SVG->PDF via svg2pdf.js when available
 */
import { jsPDF } from 'jspdf';
import html2canvas from 'html2canvas';

/**
 * @param {HTMLElement} chartElement - container element that holds the chart (canvas or svg)
 * @param {Object} options
 * @param {string} [options.filename='chart.pdf']
 * @param {'a4'|'letter'|number[]} [options.format='a4'] - pdf size
 * @param {'portrait'|'landscape'} [options.orientation='landscape']
 * @param {number} [options.quality=0.95] - JPEG quality 0..1
 * @param {number} [options.scale=1.0] - rasterization scale for html2canvas (0.5 low, 1 standard, 2 high)
 * @param {boolean} [options.includeMetadata=true]
 */
export async function exportChartToPDF(chartElement, options = {}) {
  const {
    filename = 'chart.pdf',
    format = 'a4',
    orientation = 'landscape',
    quality = 0.95,
    scale = 1.0,
    includeMetadata = true,
  } = options;

  if (!chartElement) throw new Error('Chart element not found');

  try {
    const pdf = new jsPDF({ orientation, unit: 'mm', format });

    // Prefer vector export for SVG when available
    const svg = chartElement.querySelector('svg');
    if (svg) {
      // Try dynamic import of svg2pdf compatibility if available
      try { await import('svg2pdf.js'); } catch {}
      // If jsPDF has svg plugin (when svg2pdf.js present), render vector
      if (typeof pdf.svg === 'function') {
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const maxW = pageW - 20;
        const maxH = pageH - 20;
        await pdf.svg(svg, { x: 10, y: 10, width: maxW, height: maxH });
      } else {
        // Fallback to rasterizing the SVG container
        const canvas = await html2canvas(chartElement, {
          scale: Math.max(0.5, Math.min(scale, 3)),
          useCORS: true,
          backgroundColor: '#ffffff'
        });
        const imgData = canvas.toDataURL('image/jpeg', Math.max(0.1, Math.min(quality, 1)));
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const imgW = pageW - 20;
        const imgH = (canvas.height * imgW) / canvas.width;
        const finalH = Math.min(imgH, pageH - 20);
        pdf.addImage(imgData, 'JPEG', 10, 10, imgW, finalH, undefined, 'FAST');
      }
    } else {
      // Rasterize container to canvas
      const canvas = await html2canvas(chartElement, {
        scale: Math.max(0.5, Math.min(scale, 3)),
        useCORS: true,
        backgroundColor: '#ffffff'
      });
      const imgData = canvas.toDataURL('image/jpeg', Math.max(0.1, Math.min(quality, 1)));
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgW = pageW - 20;
      const imgH = (canvas.height * imgW) / canvas.width;
      const finalH = Math.min(imgH, pageH - 20);
      pdf.addImage(imgData, 'JPEG', 10, 10, imgW, finalH, undefined, 'FAST');
    }

    if (includeMetadata) {
      pdf.setProperties({
        title: 'Vizom Chart',
        subject: 'Generated by Vizom AI Chart Builder',
        author: 'Vizom',
        creator: 'Vizom'
      });
    }

    pdf.save(filename);
    return { success: true };
  } catch (error) {
    console.error('PDF export failed:', error);
    throw new Error('Failed to export PDF');
  }
}
